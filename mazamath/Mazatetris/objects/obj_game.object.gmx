<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Maza Global Variables
global.bonus = 0;
global.correct_answer = "0"
global.mazaQues = 0;
global.countdown = 0;
load_questions();


/*


                   TETRIS

        Remade in Game Maker by Davve
         http://www.stuffbydavid.com

        Feel free to edit or whatever

*/

//      We'll start with creating the play field as a two dimensional array, where the first
//      index is the row, and the second index is the column. We want it to be 10 x 20 cells.
//      A value in the array is the ID of the block in that cell (-1 if it is empty).

var a, b;
for (a = 1; a &lt;  21; a += 1)
{
    game_line[a] = 0;                   //Each row have a game_line value, which is used to determine if that row is "completed".
    for (b = 1 b &lt; 11 b += 1)
    {
        game_field[a, b] = -1;
    }
}

//      We are now creating the different pieces to be used in the game. We identify them by
//      their ID (between 0 and 6) and their rotation (between 0 and 3). Again, as a two
//      dimensional array holding strings which represent the location of the four blocks.

//I piece

game_piece[0, 0] = '0100-0100-0100-0100';
game_piece[0, 1] = '0000-1111-0000-0000';
game_piece[0, 2] = game_piece[0, 0];
game_piece[0, 3] = game_piece[0, 1];

//J piece

game_piece[1, 0] = '100-111-000';
game_piece[1, 1] = '011-010-010';
game_piece[1, 2] = '000-111-001';
game_piece[1, 3] = '010-010-110';

//L piece

game_piece[2, 0] = '001-111-000';
game_piece[2, 1] = '010-010-011';
game_piece[2, 2] = '000-111-100';
game_piece[2, 3] = '110-010-010';

//O piece

game_piece[3, 0] = '11-11';
game_piece[3, 1] = game_piece[3, 0];
game_piece[3, 2] = game_piece[3, 0];
game_piece[3, 3] = game_piece[3, 0];

//S piece

game_piece[4, 0] = '011-110-000';
game_piece[4, 1] = '010-011-001';
game_piece[4, 2] = game_piece[4, 0];
game_piece[4, 3] = game_piece[4, 1];

//T piece

game_piece[5, 0] = '010-111-000';
game_piece[5, 1] = '010-011-010';
game_piece[5, 2] = '000-111-010';
game_piece[5, 3] = '010-110-010';

//Z piece

game_piece[6, 0] = '110-011-000';
game_piece[6, 1] = '001-011-010';
game_piece[6, 2] = game_piece[6, 0];
game_piece[6, 3] = game_piece[6, 1];

//      Here's some variables that we are going to use in the game.

game_current_piece = -1;                    //The ID of the current piece.
game_current_piece_rotation = 0;            //The rotation of the current piece.
game_current_piece_x = 0;                   //The column of the current piece.
game_current_piece_y = 0;                   //The row of the current piece.
game_line_visible = 0;                      //If this variable is even, the completed rows will be visible. If odd, the completed rows will not be drawn.

game_level = 1;                             //The level (between 1 and 10). The higher level, the faster the pieces fall.
game_score = 0;                             //The score.
game_lines = 0;                             //Number of completed lines. The level is increased after four completed lines.


//      Here are the controls used in the game.

game_keymoveleft = vk_left;
game_keymoveright = vk_right;
game_keyrotate = vk_up;
game_keymovedown = vk_down;
game_keyhighscores = ord('H');

//      Set the look of the highscores.

highscore_set_font('MS Sans Serif', 10, 0)
highscore_set_colors(c_ltgray, c_blue, c_black);

//      Set the alarm to a value between 20 and 3 steps, depending on the level.

alarm[0] = max(3, 22 - (game_level * 2));


// MAZA
alarm[1] = 700;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Maza: Generates Random Questions to be asked in the game periodically

//show_message("Answer the following question to get bonus points and BASE ROW !");

// Level 1 random numbers
n1 = irandom_range(5,12);
n2 = irandom_range(12,35);

// Calculate the HCF
h = hcf(n1,n2);

// To get random sequence of choices, add to list, shuffle and read values
list_values=ds_list_create();
ds_list_add(list_values,1); 
ds_list_add(list_values,2); 
ds_list_add(list_values,3); 
ds_list_add(list_values,4); 
ds_list_shuffle(list_values);
a = ds_list_find_value(list_values,0) ;
b = ds_list_find_value(list_values,1) ;
c = ds_list_find_value(list_values,2) ;
d = ds_list_find_value(list_values,3) ;

// Make answer choices... right now only simple choices are made
ans_array[a] = h ;
ans_array[b] = h+2;
ans_array[c] = h+1;
ans_array[d] = h+5;

// Assign the randomnly picked correct answer choice for evaluation
if (a==1){
    global.correct_answer="a";
}
if (a==2){
    global.correct_answer="b";
}
if (a==3){
    global.correct_answer="c";
}
if (a==4){
    global.correct_answer="d";
}

// Frame the question and the answer(s)
qStr = "What is the GCD [HCF] of " + string (n1) + " and " + string (n2) + " ? Press the right key (a,b,c or d)";
cStr = "a. " + string (ans_array[1]) +  " b. " + string (ans_array[2]) + " c. " + string (ans_array[3]) + " d. " + string (ans_array[4]) ;

// Use the generated questions instead of the above
n1 = irandom_range(0,50);
n2 = irandom_range(0,100);
// Choose evenly randomnly between LCM and HCF

if (n2 &lt; 50){
    qStr = global.lcm_questions[n1,0];
    cStr = "a." + string (global.lcm_questions[n1,1]) +  "  b." + string (global.lcm_questions[n1,2]) + "  c." + string (global.lcm_questions[n1,3]) + "  d." + string (global.lcm_questions[n1,4]) + "  e." + string (global.lcm_questions[n1,5] );
    global.correct_answer = global.lcm_questions[n1,6];
}
else{
    qStr = global.gcd_questions[n1,0];
    cStr = "a." + string (global.gcd_questions[n1,1]) +  "  b." + string (global.gcd_questions[n1,2]) + "  c." + string (global.gcd_questions[n1,3]) + "  d." + string (global.gcd_questions[n1,4]) + "  e." + string (global.gcd_questions[n1,5] );
    global.correct_answer = global.gcd_questions[n1,6];
}

// Write the question with white font as there can be any colored block (except white) at the back
draw_set_font(fnt_maza);
draw_set_color(c_white);
draw_set_halign(fa_center);
draw_text_ext(room_width/2,20, qStr ,20, 150 );
draw_set_color(c_white);
draw_text_ext(room_width/2,250, cStr,20, 150 );
screen_refresh() ;
keyboard_wait();
//io_clear();

global.mazaQues = 1;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//      In this event, we first check if there are any completed rows to be deleted.

var a, b, c, d, lines, free, xx, yy, str;

if (game_line_visible &gt; 0)
{
    game_line_visible += 1;
    alarm[0] = 7;
    if (game_line_visible &gt; 4)          //Time to delete the completed rows! :D
    {
        game_line_visible = 0;
        lines = 0;
        for (a = 20; a &gt; 1; a -= 1)             //Check the field for completed rows.
        {
            if (game_line[a] == 1)
            {
                game_lines += 1;
                lines += 1;
                for (b = a; b &gt; 1; b -= 1)      //Loop through the field and move all the blocks down.
                {
                    for (c = 1; c &lt; 11; c += 1)
                    {
                        game_field[b, c] = game_field[b - 1, c];
                        game_line[b] = game_line[b - 1];
                    }
                }
                a += 1;
            }
        }
        switch lines            //Add to the score, depending on the current level and how many rows the player completed.
        {
            case 1:
            {
                game_score += 40 * game_level;
                break;
            }
            case 2:
            {
                game_score += 100 * game_level;
                break;
            }
            case 3:
            {
                game_score += 300 * game_level;
                break;
            }
            case 4:
            {
                game_score += 1200 * game_level;
                break;
            }
        }
        if (game_lines &gt; 3 &amp;&amp; game_level &lt; 10)      //Go to the next level, if the player have completed four or more lines.
        {
            game_lines = 0;
            game_level += 1;
        }
        alarm[0] = max(3, 22 - (game_level * 2));       //Set the alarm to a value between 20 and 3 steps, depending on the level.
    }
    exit;
}

//      If there is no piece in play, we create a new one.

if (game_current_piece == -1)
{
    game_current_piece = choose(0, 1, 2, 3, 4, 5, 6);
    game_current_piece_rotation = 0;
    game_current_piece_x = 5;
    game_current_piece_y = 0;
}

//      We now check if the current piece are about to collide with any blocks on the play field.

str = game_piece[game_current_piece, game_current_piece_rotation];
xx = 0;
yy = 0;
free = 1;
for (a = 1; a &lt; string_length(str) + 1; a += 1)     //Loop through the string of the current piece.
{
    if (string_char_at(str, a) == '1')              //We have found a block!
    {
        if (game_current_piece_y + yy + 1 &gt; 20)     //Check if that block have hit the floor.
        {
            free = 0;
            break;
        }
        if (game_field[game_current_piece_y + yy + 1, game_current_piece_x + xx] &gt; -1)      //Check if there is another block below.
        {
            free = 0;
            break;
        }
    }
    xx += 1;
    if (string_char_at(str, a) == '-')          //Jump down if we encounter a '-'.
    {
        yy += 1;
        xx = 0;
    }
}
if (free == 1)              //Move the current piece down if the coast is clear!
{
    game_current_piece_y += 1;
}
else                        //If not...
{
    if (game_current_piece_y == 0)          //If the piece was just created, GAME OVER!
    {
        highscore_set_strings('Tetris highscores', '---', 'Press Enter or Escape to try again!')
        highscore_show(game_score);
        game_restart();
    }
    xx = 0;
    yy = 0;
    for (a = 1; a &lt; string_length(str) + 1; a += 1)     //Loop through the string of the current piece and add each block to the field.
    {
        if (string_char_at(str, a) == '1')              //If we encounter a '1', add the block to the field.
        {
            game_field[game_current_piece_y + yy, game_current_piece_x + xx] = game_current_piece;
        }
        xx += 1;
        if (string_char_at(str, a) == '-')               //Jump down if we encounter a '-'.
        {
            yy += 1;
            xx = 0;
        }
    }
    game_current_piece = -1;
    d = 0;
    for (a = 1; a &lt; 21; a += 1)         //Check for completed rows...
    {
        c = 0;
        for (b = 1; b &lt; 11; b += 1)
        {
            if (game_field[a, b] &gt; -1)
            {
                c += 1;
                d = 1;
            }
        }
        if (c == 10)                    //Row number a is completed!
        {
            game_line[a] = 1;
            game_line_visible = 1;
        }
    }
    if (d == 1)
    {
        alarm[0] = 10;
        exit;
    }
}

alarm[0] = max(3, 22 - (game_level * 2));       //Set the alarm to a value between 20 and 3 steps, depending on the level.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//      Set the window caption where the score and current level is shown.

room_caption = 'MAZA TETRIS - Score: ' + string(game_score) + ' - L: '+ string(game_level);


// Maza:Break... If the question is asked, force him to answer
i = 0;
if (global.mazaQues == 1){
   do{
       if (keyboard_check_pressed(ord('A')) || keyboard_check_pressed(ord('B')) || keyboard_check_pressed(ord('C')) || keyboard_check_pressed(ord('D'))  || keyboard_check_pressed(ord('E'))){
            i = 1;
       }
       else{
            keyboard_wait();
       }
   } until (i == 1)
} 



//      In each step, we have to check if the player wants to move the current piece, using the controls
//      that were defined in the create event.

var a, free, move, str, xx, yy;

if (keyboard_check_pressed(game_keymoveleft) || keyboard_check_pressed(game_keymoveright) &amp;&amp; game_current_piece  &gt;-1)
{
    str = game_piece[game_current_piece, game_current_piece_rotation];
    move = keyboard_check_pressed(game_keymoveright) + (-1 * keyboard_check_pressed(game_keymoveleft))      //Move the piece left (-1) or right (1)?
    game_current_piece_x += move;
    xx = 0;
    yy = 0;
    for (a = 1; a &lt; string_length(str) + 1; a += 1)                                     //Loop through the string of the current piece.
    {
        if (string_char_at(str, a) == '1')                                              //We have found a block!
        {
            if (game_current_piece_x + xx &lt; 1 || game_current_piece_x + xx &gt; 10)        //Check if the block is outside the field (less than 1 or larger than 10).
            {
                game_current_piece_x -= move;                   //Undo the move.
                break;
            }
            if (game_field[game_current_piece_y + yy, game_current_piece_x + xx] &gt; -1)  //Check if there already is a block in the new cell.
            {
                game_current_piece_x -= move;                   //Undo the move.
                break;
            }
        }
        xx += 1;
        if (string_char_at(str, a) == '-')                      //Jump down if we encounter a '-'.
        {
            xx = 0;
            yy += 1;
        }
    }
}

//      We also need to check if the player wants to rotate the current piece.

if (keyboard_check_pressed(game_keyrotate) &amp;&amp; game_current_piece &gt; -1 &amp;&amp; game_current_piece_y &gt; 0)
{
    game_current_piece_rotation += 1;                                               //Add 1 to the rotation variable.
    game_current_piece_rotation = game_current_piece_rotation mod 4;                //If the rotation is larger than 3, it will automaticly jump down to 0.
    str = game_piece[game_current_piece, game_current_piece_rotation];
    xx = 0;
    yy = 0;
    free = 1;
    for (a = 1; a &lt; string_length(str) + 1; a += 1)                                 //Loop through the string of the current piece.
    {
        if (string_char_at(str, a) == '1')                                          //We have found a block!
        {
            if (game_current_piece_x + xx &lt; 1 || game_current_piece_x + xx &gt; 10)    //Check if the block is outside the field (less than 1 or larger than 10).
            {
                free = 0;
                break;
            }
            if (game_current_piece_y + yy &gt; 20)                                     //Check if the block is below the floor.
            {
                free = 0;
                break;
            }
            if (game_field[game_current_piece_y + yy, game_current_piece_x + xx] &gt; -1)      //Check if there already is a block in the new cell.
            {
                free = 0;
                break;
            }
        }
        xx += 1;
        if (string_char_at(str, a) == '-')              //Jump down if we encounter a '-'.
        {
            yy += 1;
            xx = 0;
        }
    }
    if (free == 0)          //If the new space is taken, undo the rotation.
    {
        game_current_piece_rotation -= 1;
        if (game_current_piece_rotation &lt; 0)
        {
            game_current_piece_rotation = 3;
        }
    }
}

//      Check if the player wants to move the piece down.

if (keyboard_check(game_keymovedown) &amp;&amp; game_current_piece &gt; -1 &amp;&amp; alarm[0] &gt; 1)
{
    alarm[0] = 1;
}

//      Check if the player wants to see the highscores.

if (keyboard_check_pressed(game_keyhighscores))
{
    highscore_set_strings('Tetris highscores', '---', 'Press Enter or Escape to go back to the game!');
    highscore_show(-1);
}


// MAZA Code
if (global.mazaQues == 1){
    // Compare the key pressed with correct answer
    if (keyboard_check_pressed(ord('A'))){
     if (global.correct_answer = "a"){
        game_score = game_score + 100 ;
        global.bonus = 1;
     }
     else{
        global.bonus = 0;
     }
    }
    if (keyboard_check_pressed(ord('B'))){
     if (global.correct_answer = "b"){
        game_score = game_score + 100 ;
        global.bonus = 1;
     }
     else{
        global.bonus = 0;
     }
    }
    if (keyboard_check_pressed(ord('C'))){
     if (global.correct_answer = "c"){
        game_score = game_score + 100 ;
        global.bonus = 1;
     }
     else{
        global.bonus = 0;
     }
    }
    if (keyboard_check_pressed(ord('D'))){
     if (global.correct_answer = "d"){
        game_score = game_score + 100 ;
        global.bonus = 1;
     }
     else{
        global.bonus = 0;
     }
    }
    if (keyboard_check_pressed(ord('E'))){
     if (global.correct_answer = "e"){
        game_score = game_score + 100 ;
        global.bonus = 1;
     }
     else{
        global.bonus = 0;
     }
    }
    
    // Check if bonus needs to be given 
    if (global.bonus == 1){
        global.bonus = 0;
    
        // If the answer is right reward with solving the base line
        game_line[20] = 1;
        for (b = 1 ; b &lt; 11 ; b += 1){
            game_field[20, b] = 1;
        }
        game_line_visible = 5;
        global.correct_answer = "rishi";
    
        // Set the next question periodic time
    }
    global.mazaQues = 0;
    alarm[1] = 700;
    global.countdown = 700;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//      The draw event will handle the drawing of the field and the current piece.

var a, b, str, xx, yy;

if (game_current_piece &gt; -1)
{
    xx = 0;
    yy = 0;
    str = game_piece[game_current_piece, game_current_piece_rotation];
    for (a = 1; a &lt; string_length(str) + 1; a += 1)                    //Loop through the string of the current piece.
    {
        if (string_char_at(str, a) == '1')                          //Draw a block if we encounter a '1'.
        {
            draw_sprite(spr_game, game_current_piece, (game_current_piece_x + xx) * 16, (game_current_piece_y + yy) * 16);
        }
        xx += 1;
        if (string_char_at(str, a) == '-')                          //Jump down if we encounter a '-'.
        {
            xx = 0;
            yy += 1;
        }
    }
}

for (a = 0; a &lt; 22; a += 1)            //Loop through the field.
{
    for (b = 0; b &lt; 12; b += 1)
    {
        if (b &gt; 0 &amp;&amp; b &lt; 11 &amp;&amp; a &gt; 0 &amp;&amp; a &lt; 21)
        {
            if (game_field[a, b] &gt; -1 &amp;&amp; (game_line[a] == 0 || (game_line_visible mod 2) == 1))       //Draw a block if the row is not "completed".
            {
                draw_sprite(spr_game, game_field[a, b], b * 16, a * 16);
            }
        }
        else
        {
            draw_sprite(spr_game, 7, b * 16, a * 16);           //Draw the border.
        }
    }
}

draw_text(150,0, string(global.countdown));
if (global.countdown &gt; 0){
    global.countdown = global.countdown - 1;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
</object>
